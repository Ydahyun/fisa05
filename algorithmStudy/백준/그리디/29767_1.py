# 백준 29767번
# <문제> 점수를 최대로: 문제 설명
"""
단대소프트고에는 교실 
$N$개가 있다. 교실은 
$1$번부터 
$N$번까지 
$1, 2, \ldots, N$ 순서로 연달아 있다.

학교 밖에는 
$K$명의 학생들이 있다. 
$K$명의 학생은 학교에 들어가기 전 학생마다 목적지 교실을 정하게 된다. 
$j$번째 학생의 목적지는 
$B_j$번 교실이다. 학생들의 목적지는 모두 달라야 한다. 
$j$번째 학생은 
$1$번 교실, 
$2$번 교실, 
$\ldots, B_j$번 교실까지 모든 교실에 들어갔다 나오게 된다. 마지막 교실까지 들어갔다 나오게 되면 아무 교실도 방문하지 않고 다시 학교 밖으로 나간다.

모든 학생의 방문이 끝나면, 교실의 점수를 구할 수 있다. 
$i$번째 교실의 점수는 
$A_i$ × (
$i$번째 교실에 학생이 들어갔다 나온 횟수)가 된다. 학생들은 학교에 들어가기 전 방문 후의 교실의 점수의 합이 최대가 되도록 의논하여 목적지를 정한다. 이때 방문이 끝난 후 모든 교실의 점수의 합을 구해보자.
"""

# 입력
"""
첫째 줄에 
$N$과 
$K$가 공백으로 구분되어 입력된다. 
$(1≤K≤N≤300\,000)$ 

둘째 줄에 정수 
$A_1, A_2, ... A_N$이 공백으로 구분되어 입력된다. 
$(-10^8≤A_i≤10^8)$ 

5 3
3 -5 2 -1 4
"""

# 출력
"""
첫째 줄에 방문이 끝난 후 모든 교실의 점수의 합을 출력한다.

6

학생들의 목적지를 1번, 3번, 5번 교실로 정한다.

1번 교실의 방문 횟수는 3이고 교실의 점수는 3 × 3 = 9가 된다.
2번 교실의 방문 횟수는 2이고 교실의 점수는 -5 × 2 = -10가 된다.
3번 교실의 점수는 2 × 2 = 4이다.
4번 교실의 점수는 -1 × 1 = -1이다.
5번 교실의 점수는 4 × 1 = 4다.
모든 교실의 점수의 합은 9 - 10 + 4 - 1 + 4 = 6이고 이 경우가 최대가 된다.
"""

# 내 풀이 아이디어
"""
학생들의 목적지는 다 달라야함
가서 점수먹었어. 앞에가면 잃어 그럼멈춰
양수네? 또먹어 이렇게 계속 가보자
음수면 멈춰 이렇게 한 번 짜보자.

그리디 알고리즘이 항상 최적해를 도출하는 것은 아님.
그냥 단지 그때 순간에 이기적으로만 판단.
그 순간만 생각해.
주식으로 이야기하면, 이거 존버하면 오르겠지? 노드 한 번 더가면 이득이겠지? 이거아니야.
컴퓨터는 멍청해서 이런거 판단 못 해.
그냥 그 순간의, 눈 앞의 이기심으로만 판단한다.

"""
# 입력부
# n,k = map(int, input().split())    # 교실n 학생k
# score = map(int, input().split())  # 교실별 점수
# list_score = [*score] # 각 후보별 득표수를 담을 리스트

n, k = 5, 3
list_score = [3,-5,2,-1,4]

# 교실 초기 값 세팅
cnt = 0  # 교실 방문횟수
class_info = []  # 교실의 가중치(int)와 방문횟수(int), 학생들의 목적지(bool)로 2차원 리스트로 넣어줄거임
for score in list_score:
    class_info.append([score, cnt, False])

                     # [[교실가중치, 방문횟수, 학생들의 최종목적지]]
# print(class_info)  # [[3, 0, False], [-5, 0, False], [2, 0, False], [-1, 0, False], [4, 0, False]]

for _ in range(k):  # 학생 수만큼 반복
    for j in range(n-1):  # 교실수-1 만큼 반복 (index out of range 오류 방지)

        if class_info[j][-1] == True:
            class_info[j][1] +=1
            continue

        if class_info[j][0] > class_info[j+1][0]:  # 2, -1
            class_info[j][1] +=1       # 교실방문횟수 카운트
            class_info[j][-1] = True   # 이 교실을 최종목적지로 확정시킴
            break
        else:                      
            class_info[j][1] +=1       # 일단 교실 넘어가기전에 방문횟수 카운트해주고
            continue
if class_info[-1][-1] == False:
    class_info[-1][1] +=1  # 마지막 방의 경우
sum =0
for i in range(len(class_info)):
    sum +=class_info[i][0]*class_info[i][1]

print(class_info)
print(sum)
# Discussion
"""

"""