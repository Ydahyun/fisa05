# 0710 수업 회고..

**내가 몰랐던 것 위주로~**

0. 오늘 레전드 넘파이 맛있었다. 역시 파이는 맛있다.

1. 아그야,,@@ 넌 np.arange()를 아니? 오렌지 아니고 어레인지다. 전자레인지 아니다 ㅋ  
```python
np.arange(1, 10).reshape(3, 3)
# [[1 2 3]
#  [4 5 6]
#  [7 8 9]]
```
위에 보면 알긋지만@@ 3*3 2차원 행렬로 배열이 생성된다~
아, 선생님. 저는 직관적으로 그냥 만들고싶은데요?
2. 그럼 너는 np.array()로 노가다 뛰어라.
```python
np.array([[1,2,3],[4,5,6],[7,8,9]])
```
오 이렇게 보니까 직관적으로 보이니 얼마나 좋아요 ㅎ 더 가독성 좋게 써볼까요?
```python
np.array([[1,2,3],
          [4,5,6],
          [7,8,9]])
```
흐음 이녀석,,,나름 머리좀굴리는구나@@  
그렇다면 각 원소들마다 값을 더해주려면 어떻게 하는지 아느냐?!  
3. 당연하죵ㅋ 그냥 람다함수 처리할게용
```python
[*map(lambda x : x+5, 리스트명)]
```
예끼이놈! 위에 식은 그냥 파이썬 내장 기능아니더냐!  
넘파이 라이브러리는 무려 아래와 같은 편리한 기능을 제공한단다!  
```python
a=np.array([1,2,3])
a=a+5  # array([6, 7, 8])
```
와 미쵸따.. 선생님 너무 신기해요 ㄷㄷ 진짜 짱 편하다()  
"(다셨으놓어집뒤를대무)"[::-1]  
4. 이거는 그냥 알아두거라 어차피 다 알지않느냐?  
```python
print(test.itemsize) # 한 원소가 차지하는 방의 byte 사이즈
print(test.dtype) # 자료형
print(test.ndim) # 차원
print(test.size) # 원소의 전체 개수
print(test.shape) # ndarray의 구조  (5,) - 튜플
print(test.strides) # 보폭

# 8
# int64
# 2
# 9
# (3, 3)
# (24, 8)
```
당연하죵ㅋ  
6. 넘파이도 파이썬 기본 리스트와 같이 append()가 있다네..  
```python
a=np.arange(0,10).reshape(2,5)
a
# array([[0, 1, 2, 3, 4],
#        [5, 6, 7, 8, 9]])

np.append(a, 40)
# array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 40])
```
다만 참고할건 차원이 맞지 않으면 1차원으로 결과를 리턴해버려..  

허거거거걱 그럼 어떻게 하죵?!?!  
일단 차원이 맞는 데이터를 넣어주어야겠지...  
```python
np.append(a, [[2,1]])
# array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 2, 1])
```
안되는데요. 싸부.  
으휴,,,아직 애송이구만@@ 잘보게나 스킬사용!  
```python
np.append(a, [[2,1]], axis=0)
# array([[0, 1],
#        [2, 3],
#        [4, 5],
#        [6, 7],
#        [8, 9],
#        [2, 1]])
```
아아아닛?!?! axis=0으로해서 아래 축에 넣어버리다니!! 크윽 대단한 기술이다.. axis=1이면 오른쪽으로 붙겠지?  
대단한 응용력이다. 분발해라. 항상 자료의 차원을 유심히 보거라..  
7. 크윽.. np.zeors(), np.ones()같은 것만 잡기술이라고 익히고 있었군.. 분발하자  
```python
np.zeros((3, 1, 3)) # 초기화
# array([[[0., 0., 0.]],

#        [[0., 0., 0.]],

#        [[0., 0., 0.]]])

np.ones(3) # 초기화
# array([1., 1., 1.])
```
8. 맞다 싸부 정렬은 어떻게 해요?!  
애송아..
```python
x = np.array([100, 3, 20, 50, 80, 4])
np.sort(x)
# array([  3,   4,  20,  50,  80, 100])

# 내림차순 정렬
np.sort(x)[::-1]
# array([100,  80,  50,  20,   4,   3])

# or
np.flip(np.sort(x))

# array([100,  80,  50,  20,   4,   3])
```
9. 조건은 아느냐..? 알리가...
```python
x = np.array([1,2,3,4,5])

# np.all - 모든 원소가 특정조건을 만족하면 T, F
np.all(x<13)
# np.True_
np.any(x<4) # 하나라도 특정조건을 만족하면 T, F
# np.True_

np.isnan(x) # nan의 여부를 T/F로 리턴
np.isnan(x).sum() # nan의 개수를 셀 수 있게 됩니다.
np.isinf(x)  # np.inf 만 True
np.isfinite(x) # np.nan, np.inf 처리되지 않을 값들에 대해 False
np.isnan(x).sum() + np.isinf(x).sum()
np.sum(~np.isfinite(x)) # 비트연산자 not
```
10. 그래도 슬라이싱은 잘해여 ㅎ  



## My Discussion
**파이썬 list가 느린 이유**

- 파이썬 리스트는 결국 포인터의 배열
- 경우에 따라서 각각 객체가 메모리 여기저기 흩어져 있음
- 그러므로 캐시 활용이 어려움

**NumPy ndarray가 빠른 이유**

- ndarray는 타입을 명시하여 원소의 배열로 데이터를 유지
- 다차원 데이터도 연속된 메모리 공간이 할당됨
- 많은 연산이 dimensions과 strides를 잘 활용하면 효율적으로 가능
- ndarray 구현 방식을 떠올리면 어떻게 성능을 낼 수 있는지 상상 가능  

(참고2) strides
- '걸음걸이, 보폭'이라는 뜻을 가지고 있는 단어
- numpy에서는, 각 dimensions를 건너가는데 몇 bytes나 뛰어넘어야 하는지에 대한 정보

    예를들어 [[1,2,3],[4,5,6]] 이라는 2차원의 array가 있다면 strides를 사용하면 (dimensions 간의 간격, 앨리먼트간의 간격) 으로 결과가 출력된다. 각 dimensions 간의 간격은 [1,2,3] 의 용량과 같으므로 4바이트인 int32형 3개 = 12 bytes인 것.

